/*! firebase-admin v4.0.5
    https://firebase.google.com/terms/ */
"use strict";
var deep_copy_1 = require("./utils/deep-copy");
var credential_1 = require("./auth/credential");
/**
 * Internals of a FirebaseApp instance.
 */
var FirebaseAppInternals = (function () {
    function FirebaseAppInternals(credential_) {
        this.credential_ = credential_;
        this.tokenListeners_ = [];
    }
    /**
     * Gets an auth token for the associated app.
     *
     * @param {boolean} forceRefresh Whether or not to force a token refresh.
     * @return {Promise<Object>} A Promise that will be fulfilled with the current or new token.
     */
    FirebaseAppInternals.prototype.getToken = function (forceRefresh) {
        var _this = this;
        var expired = this.cachedToken_ && this.cachedToken_.expirationTime < Date.now();
        if (this.cachedTokenPromise_ && !forceRefresh && !expired) {
            return this.cachedTokenPromise_;
        }
        else {
            // this.credential_ may be an external class; resolving it in a promise helps us
            // protect against exceptions and upgrades the result to a promise in all cases.
            this.cachedTokenPromise_ = Promise.resolve(this.credential_.getAccessToken())
                .then(function (result) {
                if (result === null) {
                    return null;
                }
                // Since the developer can provide the credential implementation, we want to weakly verify
                // the return type until the type is properly exported.
                if (typeof result !== 'object' ||
                    typeof result.expires_in !== 'number' ||
                    typeof result.access_token !== 'string') {
                    throw new Error("Invalid access token generated: " + JSON.stringify(result) + ". Valid access tokens must " +
                        'be an object with the "expires_in" (number) and "access_token" (string) properties.');
                }
                var token = {
                    accessToken: result.access_token,
                    expirationTime: Date.now() + (result.expires_in * 1000),
                };
                var hasAccessTokenChanged = (_this.cachedToken_ && _this.cachedToken_.accessToken !== token.accessToken);
                var hasExpirationChanged = (_this.cachedToken_ && _this.cachedToken_.expirationTime !== token.expirationTime);
                if (!_this.cachedToken_ || hasAccessTokenChanged || hasExpirationChanged) {
                    _this.cachedToken_ = token;
                    _this.tokenListeners_.forEach(function (listener) {
                        listener(token.accessToken);
                    });
                }
                return token;
            })
                .catch(function (error) {
                // Update the cached token promise to avoid caching errors. Set it to resolve with the
                // cached token if we have one; otherwise, set it to null.
                if (_this.cachedToken_) {
                    _this.cachedTokenPromise_ = Promise.resolve(_this.cachedToken_);
                }
                else {
                    _this.cachedTokenPromise_ = null;
                }
                var errorMessage = 'Credential implementation provided to initializeApp() via the ' +
                    '"credential" property failed to fetch a valid Google OAuth2 access token with the ' +
                    ("following error: \"" + error.message + "\".");
                if (error.message.indexOf('invalid_grant') !== -1) {
                    errorMessage += ' The most likely cause of this error is using a certificate key file ' +
                        'which has been revoked. Make sure the key ID for your key file is still present at ' +
                        'https://console.firebase.google.com/iam-admin/serviceaccounts/project. If not, generate' +
                        'a new key file at https://console.firebase.google.com/project/_/settings/serviceaccounts/adminsdk.';
                }
                throw new Error(errorMessage);
            });
            return this.cachedTokenPromise_;
        }
    };
    /**
     * Adds a listener that is called each time a token changes.
     *
     * @param {function(string)} listener The listener that will be called with each new token.
     */
    FirebaseAppInternals.prototype.addAuthTokenListener = function (listener) {
        this.tokenListeners_.push(listener);
        if (this.cachedToken_) {
            listener(this.cachedToken_.accessToken);
        }
    };
    /**
     * Removes a token listener.
     *
     * @param {function(string)} listener The listener to remove.
     */
    FirebaseAppInternals.prototype.removeAuthTokenListener = function (listener) {
        this.tokenListeners_ = this.tokenListeners_.filter(function (other) { return other !== listener; });
    };
    return FirebaseAppInternals;
}());
exports.FirebaseAppInternals = FirebaseAppInternals;
/**
 * Global context object for a collection of services using a shared authentication state.
 */
var FirebaseApp = (function () {
    function FirebaseApp(options, name, firebaseInternals_) {
        var _this = this;
        this.firebaseInternals_ = firebaseInternals_;
        this.services_ = {};
        this.isDeleted_ = false;
        this.name_ = name;
        this.options_ = deep_copy_1.deepCopy(options);
        if (typeof this.options_ !== 'object' || this.options_ === null) {
            // Ensure the options are a non-null object
            this.options_ = {};
        }
        var hasCredential = ('credential' in this.options_);
        var hasServiceAccount = ('serviceAccount' in this.options_);
        var errorMessage;
        if (!hasCredential && !hasServiceAccount) {
            errorMessage = 'Options must be an object containing at least a "credential" property.';
        }
        else if (hasCredential && hasServiceAccount) {
            errorMessage = 'Options cannot specify both the "credential" and "serviceAccount" properties.';
        }
        // TODO(jwenger): NEXT MAJOR RELEASE - throw error if the "credential" property is not specified
        if (hasServiceAccount) {
            var serviceAccount = this.options_.serviceAccount;
            var serviceAccountIsString = (typeof serviceAccount === 'string');
            var serviceAccountIsNonNullObject = (typeof serviceAccount === 'object' && serviceAccount !== null);
            if (!serviceAccountIsString && !serviceAccountIsNonNullObject) {
                errorMessage = 'The "serviceAccount" property must be a string representing the file path to ' +
                    'a key file or an object representing the contents of a key file.';
            }
        }
        else if (hasCredential) {
            var credential = this.options_.credential;
            if (typeof credential !== 'object' || credential === null || typeof credential.getAccessToken !== 'function') {
                errorMessage = 'The "credential" property must be an object which implements the Credential interface.';
            }
        }
        if (typeof errorMessage !== 'undefined') {
            throw new Error("Invalid Firebase app options passed as the first argument to initializeApp() for the " +
                ("app named \"" + this.name_ + "\". " + errorMessage));
        }
        // TODO(jwenger): NEXT MAJOR RELEASE - remove "serviceAccount" property deprecation warning and
        // relevant error handling above
        if (hasServiceAccount) {
            /* tslint:disable:no-console */
            console.warn('WARNING: The "serviceAccount" property specified in the first argument to initializeApp() ' +
                'is deprecated and will be removed in the next major version. You should instead use the ' +
                '"credential" property.');
            /* tslint:enable:no-console */
            this.options_.credential = new credential_1.CertCredential(this.options_.serviceAccount);
        }
        Object.keys(firebaseInternals_.serviceFactories).forEach(function (serviceName) {
            // Defer calling createService() until the service is accessed
            _this[serviceName] = _this.getService_.bind(_this, serviceName);
        });
        this.INTERNAL = new FirebaseAppInternals(this.options_.credential);
        // Asynchronously ensure the provided credential can generate OAuth access tokens. We explicitly
        // call this here to provide the developer with an error as soon as possible and so that each
        // individual service doesn't have to worry about logging this class of error. Because getToken()
        // caches tokens, there is no real performance penalty for calling this here.
        this.INTERNAL.getToken()
            .catch(function (error) {
            /* tslint:disable:no-console */
            console.error(error);
            /* tslint:enable:no-console */
        });
    }
    /**
     * Firebase services available off of a FirebaseApp instance. These are monkey-patched via
     * registerService(), but we need to include a dummy implementation to get TypeScript to
     * compile it without errors.
     */
    /* istanbul ignore next */
    FirebaseApp.prototype.auth = function () {
        throw new Error('INTERNAL ASSERT FAILED: Firebase auth() service has not been registered.');
    };
    /* istanbul ignore next */
    FirebaseApp.prototype.database = function () {
        throw new Error('INTERNAL ASSERT FAILED: Firebase database() service has not been registered.');
    };
    Object.defineProperty(FirebaseApp.prototype, "name", {
        /**
         * Returns the name of the FirebaseApp instance.
         *
         * @returns {string} The name of the FirebaseApp instance.
         */
        get: function () {
            this.checkDestroyed_();
            return this.name_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirebaseApp.prototype, "options", {
        /**
         * Returns the options for the FirebaseApp instance.
         *
         * @returns {FirebaseAppOptions} The options for the FirebaseApp instance.
         */
        get: function () {
            this.checkDestroyed_();
            return deep_copy_1.deepCopy(this.options_);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Deletes the FirebaseApp instance.
     *
     * @returns {Promise<void>} An empty Promise fulfilled once the FirebaseApp instance is deleted.
     */
    FirebaseApp.prototype.delete = function () {
        var _this = this;
        this.checkDestroyed_();
        this.firebaseInternals_.removeApp(this.name_);
        return Promise.all(Object.keys(this.services_).map(function (serviceName) {
            return _this.services_[serviceName].INTERNAL.delete();
        })).then(function () {
            _this.services_ = {};
            _this.isDeleted_ = true;
        });
    };
    /**
     * Returns the service instance associated with this FirebaseApp instance (creating it on demand
     * if needed).
     *
     * @param {string} serviceName The name of the service instance to return.
     * @return {FirebaseServiceInterface} The service instance with the provided name.
     */
    FirebaseApp.prototype.getService_ = function (serviceName) {
        this.checkDestroyed_();
        if (!(serviceName in this.services_)) {
            this.services_[serviceName] = this.firebaseInternals_.serviceFactories[serviceName](this, this.extendApp_.bind(this));
        }
        return this.services_[serviceName];
    };
    /**
     * Callback function used to extend an App instance at the time of service instance creation.
     */
    FirebaseApp.prototype.extendApp_ = function (props) {
        deep_copy_1.deepExtend(this, props);
    };
    /**
     * Throws an Error if the FirebaseApp instance has already been deleted.
     */
    FirebaseApp.prototype.checkDestroyed_ = function () {
        if (this.isDeleted_) {
            throw new Error("Firebase app named \"" + this.name_ + "\" has already been deleted.");
        }
    };
    return FirebaseApp;
}());
exports.FirebaseApp = FirebaseApp;
